<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Centerline Generator - Telugu Letters</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            padding: 30px;
        }
        
        h1 {
            color: #667eea;
            margin-bottom: 10px;
            text-align: center;
        }
        
        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
        }
        
        .controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .control-group {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
        }
        
        .control-group label {
            display: block;
            font-weight: bold;
            margin-bottom: 8px;
            color: #495057;
        }
        
        textarea {
            width: 100%;
            min-height: 100px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
            margin-bottom: 10px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            resize: vertical;
        }
        
        button {
            background: #667eea;
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s;
            margin: 5px 5px 5px 0;
        }
        
        button:hover {
            background: #764ba2;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        
        button.danger {
            background: #dc3545;
        }
        
        button.success {
            background: #28a745;
        }
        
        .canvas-container {
            background: white;
            border: 2px solid #ddd;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            overflow: auto;
            position: relative;
        }
        
        #svgCanvas {
            border: 1px solid #ccc;
            background: #fafafa;
            cursor: crosshair;
            display: block;
            margin: 0 auto;
        }
        
        .info-box {
            background: #e7f3ff;
            border-left: 4px solid #2196F3;
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
        }
        
        .output-box {
            background: #f8f9fa;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 15px;
            margin-top: 20px;
        }
        
        .output-box textarea {
            width: 100%;
            min-height: 150px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            resize: vertical;
        }
        
        .status {
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
            font-weight: bold;
        }
        
        .status.info {
            background: #d1ecf1;
            color: #0c5460;
        }
        
        .status.success {
            background: #d4edda;
            color: #155724;
        }
        
        .status.warning {
            background: #fff3cd;
            color: #856404;
        }
        
        .stroke-controls {
            background: #fff3cd;
            border: 2px solid #ffc107;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }
        
        .stroke-controls h3 {
            margin: 0 0 10px 0;
            color: #856404;
        }
        
        .stroke-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 10px;
        }
        
        .stroke-button {
            background: #ffc107;
            color: #000;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            border: 2px solid transparent;
            font-weight: bold;
        }
        
        .stroke-button:hover {
            background: #ffb300;
        }
        
        .stroke-button.active {
            background: #ff9800;
            border-color: #f57c00;
            color: white;
        }
        
        button.info {
            background: #17a2b8;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üéØ Centerline Generator</h1>
        <p class="subtitle">Create centerline paths by placing points along the SVG path</p>
        
        <div class="controls">
            <div class="control-group">
                <label>SVG Path Input:</label>
                <textarea id="svgPathInput" placeholder="Paste SVG path here (e.g., M 100 100 L 200 200...)"></textarea>
                <button onclick="loadSVG()">Load SVG Path</button>
                <button class="danger" onclick="clearAll()">Clear All</button>
            </div>
            
            <div class="control-group">
                <label>Actions:</label>
                <button onclick="undoLastPoint()">Undo Last Point</button>
                <button class="info" onclick="startNewStroke()">New Stroke</button>
                <button class="danger" onclick="clearCurrentStroke()">Clear Current Stroke</button>
                <button class="danger" onclick="clearCenterline()">Clear All Strokes</button>
                <button class="success" onclick="exportCenterline()">Export Centerline</button>
            </div>
        </div>
        
        <div class="info-box">
            <strong>Instructions:</strong>
            <ol style="margin-top: 10px; padding-left: 20px;">
                <li>Paste the SVG path from <code>telugu_shape_paths.dart</code></li>
                <li>Click "Load SVG Path" to display the letter</li>
                <li>Click anywhere inside the letter shape to place centerline points</li>
                <li>Points will be placed exactly where you click</li>
                <li>Hover to see a preview of where the point will be placed</li>
                <li><strong>Click "New Stroke" to break the flow and start a new disconnected path</strong></li>
                <li>Use stroke buttons to switch between different strokes</li>
                <li>Each stroke is color-coded for easy identification</li>
                <li>Click "Export Centerline" to get the SVG path string (all strokes combined)</li>
                <li>Copy the output and paste it into <code>telugu_shape_paths.dart</code></li>
            </ol>
        </div>
        
        <div id="status" class="status info">Ready - Paste SVG path and click 'Load SVG Path' to begin</div>
        
        <div class="stroke-controls" id="strokeControls" style="display: none;">
            <h3>üìù Stroke Management</h3>
            <div>
                <strong>Current Stroke: <span id="currentStrokeDisplay">1</span></strong>
                <span style="margin-left: 20px;">Total Strokes: <span id="totalStrokesDisplay">1</span></span>
                <span style="margin-left: 20px;">Points in Current: <span id="currentPointsDisplay">0</span></span>
            </div>
            <div class="stroke-buttons" id="strokeButtons"></div>
        </div>
        
        <div class="canvas-container">
            <svg id="svgCanvas" width="1000" height="1000" viewBox="0 0 1000 1000"></svg>
        </div>
        
        <div class="output-box">
            <label><strong>Generated Centerline Path (SVG):</strong></label>
            <textarea id="outputPath" readonly placeholder="Centerline path will appear here..."></textarea>
            <button onclick="copyToClipboard()">Copy to Clipboard</button>
        </div>
    </div>

    <script>
        let svgElement = null;
        let mainPathElement = null;
        let centerlinePathElements = []; // Array of path elements for each stroke
        let centerlineStrokes = []; // Array of arrays, each containing points for a stroke
        let currentStrokeIndex = 0; // Index of currently active stroke
        let svgBounds = null;
        let pointCircles = []; // All point circles across all strokes
        let previewCircle = null;
        
        // Color palette for different strokes
        const strokeColors = [
            '#ff5722', // Red-orange
            '#2196F3', // Blue
            '#4CAF50', // Green
            '#FF9800', // Orange
            '#9C27B0', // Purple
            '#00BCD4', // Cyan
            '#E91E63', // Pink
            '#795548'  // Brown
        ];
        
        function loadSVG() {
            const pathInput = document.getElementById('svgPathInput').value.trim();
            if (!pathInput) {
                alert('Please paste an SVG path');
                return;
            }
            
            svgElement = document.getElementById('svgCanvas');
            svgElement.innerHTML = '';
            centerlineStrokes = [[]]; // Start with one empty stroke
            currentStrokeIndex = 0;
            centerlinePathElements = [];
            pointCircles = [];
            updateStrokeControls();
            
            // Create main path
            mainPathElement = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            mainPathElement.setAttribute('d', pathInput);
            mainPathElement.setAttribute('fill', '#e3f2fd');
            mainPathElement.setAttribute('stroke', '#1976d2');
            mainPathElement.setAttribute('stroke-width', '2');
            mainPathElement.setAttribute('id', 'mainPath');
            svgElement.appendChild(mainPathElement);
            
            // Get bounds and set viewBox
            setTimeout(() => {
                try {
                    const bbox = mainPathElement.getBBox();
                    svgBounds = bbox;
                    const padding = 50;
                    const viewBox = `${bbox.x - padding} ${bbox.y - padding} ${bbox.width + 2*padding} ${bbox.height + 2*padding}`;
                    svgElement.setAttribute('viewBox', viewBox);
                    svgElement.setAttribute('preserveAspectRatio', 'xMidYMid meet');
                    
                    // Force a reflow to ensure transformations are applied
                    svgElement.getBBox();
                    
                    updateStatus(`SVG loaded. Click anywhere inside the letter to add centerline points.`);
                } catch (e) {
                    console.error('Error getting bounds:', e);
                    updateStatus('Error loading SVG bounds', 'warning');
                }
            }, 100);
            
            // Add click and mouse move handlers
            svgElement.addEventListener('click', handleCanvasClick);
            svgElement.addEventListener('mousemove', handleMouseMove);
        }
        
        function getSVGPoint(event) {
            const rect = svgElement.getBoundingClientRect();
            
            // Get mouse position relative to the SVG element
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            
            // Get viewBox
            const viewBox = svgElement.viewBox.baseVal;
            const svgWidth = rect.width;
            const svgHeight = rect.height;
            
            // Calculate SVG coordinates from viewBox
            const svgX = viewBox.x + (x / svgWidth) * viewBox.width;
            const svgY = viewBox.y + (y / svgHeight) * viewBox.height;
            
            const point = svgElement.createSVGPoint();
            point.x = svgX;
            point.y = svgY;
            
            return point;
        }
        
        function handleMouseMove(event) {
            if (!mainPathElement) return;
            
            const svgPoint = getSVGPoint(event);
            
            // Check if point is inside the SVG shape
            if (mainPathElement.isPointInFill(svgPoint)) {
                // Remove old preview circle
                if (previewCircle && previewCircle.parentNode) {
                    previewCircle.parentNode.removeChild(previewCircle);
                }
                
                // Create preview circle at exact mouse position
                previewCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                previewCircle.setAttribute('cx', svgPoint.x);
                previewCircle.setAttribute('cy', svgPoint.y);
                previewCircle.setAttribute('r', '6');
                previewCircle.setAttribute('fill', 'rgba(255, 87, 34, 0.5)');
                previewCircle.setAttribute('stroke', '#ff5722');
                previewCircle.setAttribute('stroke-width', '2');
                previewCircle.setAttribute('id', 'previewCircle');
                previewCircle.style.pointerEvents = 'none';
                svgElement.appendChild(previewCircle);
            } else {
                // Remove preview if outside the shape
                if (previewCircle && previewCircle.parentNode) {
                    previewCircle.parentNode.removeChild(previewCircle);
                    previewCircle = null;
                }
            }
        }
        
        function handleCanvasClick(event) {
            if (!mainPathElement) return;
            
            // Remove preview circle
            if (previewCircle && previewCircle.parentNode) {
                previewCircle.parentNode.removeChild(previewCircle);
                previewCircle = null;
            }
            
            const svgPoint = getSVGPoint(event);
            
            // Check if point is inside the SVG shape
            if (mainPathElement.isPointInFill(svgPoint)) {
                // Ensure current stroke exists
                if (!centerlineStrokes[currentStrokeIndex]) {
                    centerlineStrokes[currentStrokeIndex] = [];
                }
                
                // Place point exactly where user clicked in current stroke
                centerlineStrokes[currentStrokeIndex].push({x: svgPoint.x, y: svgPoint.y});
                updateCenterlinePath();
                const pointCount = centerlineStrokes[currentStrokeIndex].length;
                updateStatus(`Stroke ${currentStrokeIndex + 1}: Added point ${pointCount} at (${svgPoint.x.toFixed(2)}, ${svgPoint.y.toFixed(2)})`);
                updateStrokeControls();
            } else {
                updateStatus('Click inside the letter shape to add points', 'warning');
            }
        }
        
        function updateCenterlinePath() {
            if (!svgElement) return;
            
            // Remove all existing centerline paths
            centerlinePathElements.forEach(pathEl => {
                if (pathEl.parentNode) {
                    pathEl.parentNode.removeChild(pathEl);
                }
            });
            centerlinePathElements = [];
            
            // Remove all existing point circles
            pointCircles.forEach(circle => {
                if (circle.parentNode) {
                    circle.parentNode.removeChild(circle);
                }
            });
            pointCircles = [];
            
            // Create paths for each stroke
            centerlineStrokes.forEach((strokePoints, strokeIdx) => {
                if (strokePoints.length === 0) return;
                
                const strokeColor = strokeColors[strokeIdx % strokeColors.length];
            
                // Create path element for this stroke
                const pathElement = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            let pathData = '';
            
                strokePoints.forEach((point, index) => {
                if (index === 0) {
                    pathData += `M ${point.x.toFixed(2)} ${point.y.toFixed(2)}`;
                } else {
                    pathData += ` L ${point.x.toFixed(2)} ${point.y.toFixed(2)}`;
                }
            });
            
                pathElement.setAttribute('d', pathData);
                pathElement.setAttribute('fill', 'none');
                pathElement.setAttribute('stroke', strokeColor);
                pathElement.setAttribute('stroke-width', strokeIdx === currentStrokeIndex ? '3' : '2');
                pathElement.setAttribute('stroke-dasharray', '5,5');
                pathElement.setAttribute('opacity', strokeIdx === currentStrokeIndex ? '1' : '0.7');
                svgElement.appendChild(pathElement);
                centerlinePathElements.push(pathElement);
            
                // Add point markers for this stroke
                strokePoints.forEach((point, index) => {
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', point.x);
                circle.setAttribute('cy', point.y);
                    circle.setAttribute('r', strokeIdx === currentStrokeIndex ? '6' : '5');
                    circle.setAttribute('fill', strokeColor);
                circle.setAttribute('stroke', 'white');
                circle.setAttribute('stroke-width', '2');
                    circle.setAttribute('data-stroke-index', strokeIdx);
                    circle.setAttribute('data-point-index', index);
                circle.style.cursor = 'pointer';
                    circle.style.opacity = strokeIdx === currentStrokeIndex ? '1' : '0.7';
                
                // Add click handler to remove point
                circle.addEventListener('click', (e) => {
                    e.stopPropagation();
                        removePoint(strokeIdx, index);
                });
                
                svgElement.appendChild(circle);
                pointCircles.push(circle);
                
                    // Add point number label (only for current stroke)
                    if (strokeIdx === currentStrokeIndex) {
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', point.x);
                text.setAttribute('y', point.y - 10);
                text.setAttribute('text-anchor', 'middle');
                text.setAttribute('font-size', '12');
                text.setAttribute('font-weight', 'bold');
                text.setAttribute('fill', '#fff');
                        text.setAttribute('stroke', strokeColor);
                text.setAttribute('stroke-width', '0.5');
                text.textContent = index + 1;
                svgElement.appendChild(text);
                    }
                });
            });
            
            // Update output
            exportCenterline();
        }
        
        function removePoint(strokeIndex, pointIndex) {
            if (strokeIndex >= 0 && strokeIndex < centerlineStrokes.length &&
                pointIndex >= 0 && pointIndex < centerlineStrokes[strokeIndex].length) {
                centerlineStrokes[strokeIndex].splice(pointIndex, 1);
                updateCenterlinePath();
                updateStatus(`Removed point ${pointIndex + 1} from stroke ${strokeIndex + 1}`);
                updateStrokeControls();
            }
        }
        
        function undoLastPoint() {
            if (centerlineStrokes[currentStrokeIndex] && centerlineStrokes[currentStrokeIndex].length > 0) {
                centerlineStrokes[currentStrokeIndex].pop();
                updateCenterlinePath();
                const pointCount = centerlineStrokes[currentStrokeIndex].length;
                updateStatus(`Removed last point from stroke ${currentStrokeIndex + 1}. Points: ${pointCount}`);
                updateStrokeControls();
            } else {
                updateStatus('No points to undo in current stroke', 'warning');
            }
        }
        
        function startNewStroke() {
            // Create a new empty stroke
            centerlineStrokes.push([]);
            currentStrokeIndex = centerlineStrokes.length - 1;
            updateCenterlinePath();
            updateStatus(`Started new stroke ${currentStrokeIndex + 1}. Click to add points.`);
            updateStrokeControls();
        }
        
        function switchStroke(strokeIndex) {
            if (strokeIndex >= 0 && strokeIndex < centerlineStrokes.length) {
                currentStrokeIndex = strokeIndex;
                updateCenterlinePath();
                updateStatus(`Switched to stroke ${currentStrokeIndex + 1}`);
                updateStrokeControls();
            }
        }
        
        function clearCurrentStroke() {
            if (centerlineStrokes[currentStrokeIndex]) {
                centerlineStrokes[currentStrokeIndex] = [];
                updateCenterlinePath();
                updateStatus(`Cleared stroke ${currentStrokeIndex + 1}`);
                updateStrokeControls();
            }
        }
        
        function clearCenterline() {
            centerlineStrokes = [[]];
            currentStrokeIndex = 0;
            centerlinePathElements = [];
            pointCircles.forEach(circle => {
                if (circle.parentNode) {
                    circle.parentNode.removeChild(circle);
                }
            });
            pointCircles = [];
            document.getElementById('outputPath').value = '';
            updateStatus('All strokes cleared');
            updateStrokeControls();
        }
        
        function updateStrokeControls() {
            const controlsDiv = document.getElementById('strokeControls');
            if (centerlineStrokes.length > 0) {
                controlsDiv.style.display = 'block';
                
                document.getElementById('currentStrokeDisplay').textContent = currentStrokeIndex + 1;
                document.getElementById('totalStrokesDisplay').textContent = centerlineStrokes.length;
                const currentPoints = centerlineStrokes[currentStrokeIndex] ? centerlineStrokes[currentStrokeIndex].length : 0;
                document.getElementById('currentPointsDisplay').textContent = currentPoints;
                
                // Update stroke buttons
                const buttonsDiv = document.getElementById('strokeButtons');
                buttonsDiv.innerHTML = '';
                centerlineStrokes.forEach((stroke, index) => {
                    const button = document.createElement('button');
                    button.className = 'stroke-button' + (index === currentStrokeIndex ? ' active' : '');
                    button.textContent = `Stroke ${index + 1} (${stroke.length} pts)`;
                    button.onclick = () => switchStroke(index);
                    buttonsDiv.appendChild(button);
                });
            } else {
                controlsDiv.style.display = 'none';
            }
        }
        
        function clearAll() {
            clearCenterline();
            if (previewCircle && previewCircle.parentNode) {
                previewCircle.parentNode.removeChild(previewCircle);
                previewCircle = null;
            }
            if (mainPathElement) {
                svgElement.removeChild(mainPathElement);
                mainPathElement = null;
            }
            svgBounds = null;
            document.getElementById('svgPathInput').value = '';
            updateStatus('All cleared');
        }
        
        function exportCenterline() {
            // Filter out empty strokes
            const nonEmptyStrokes = centerlineStrokes.filter(stroke => stroke.length > 0);
            
            if (nonEmptyStrokes.length === 0) {
                alert('No centerline points to export. Please add some points first.');
                return;
            }
            
            let pathData = '';
            let totalPoints = 0;
            
            nonEmptyStrokes.forEach((strokePoints, strokeIdx) => {
                strokePoints.forEach((point, index) => {
                if (index === 0) {
                    pathData += `M ${point.x.toFixed(2)} ${point.y.toFixed(2)}`;
                } else {
                    pathData += ` L ${point.x.toFixed(2)} ${point.y.toFixed(2)}`;
                }
                    totalPoints++;
                });
            });
            
            document.getElementById('outputPath').value = pathData;
            updateStatus(`Exported ${nonEmptyStrokes.length} stroke(s) with ${totalPoints} total points`, 'success');
        }
        
        function copyToClipboard() {
            const output = document.getElementById('outputPath');
            if (!output.value) {
                alert('No centerline path to copy. Please export first.');
                return;
            }
            output.select();
            document.execCommand('copy');
            updateStatus('Copied to clipboard!', 'success');
        }
        
        function updateStatus(message, type = 'info') {
            const statusEl = document.getElementById('status');
            statusEl.textContent = message;
            statusEl.className = `status ${type}`;
        }
    </script>
</body>
</html>

