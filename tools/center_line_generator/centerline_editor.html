<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Centerline Generator - Telugu Letters</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            padding: 30px;
        }
        
        h1 {
            color: #667eea;
            margin-bottom: 10px;
            text-align: center;
        }
        
        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
        }
        
        .controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .control-group {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
        }
        
        .control-group label {
            display: block;
            font-weight: bold;
            margin-bottom: 8px;
            color: #495057;
        }
        
        textarea {
            width: 100%;
            min-height: 100px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
            margin-bottom: 10px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            resize: vertical;
        }
        
        button {
            background: #667eea;
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s;
            margin: 5px 5px 5px 0;
        }
        
        button:hover {
            background: #764ba2;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        
        button.danger {
            background: #dc3545;
        }
        
        button.success {
            background: #28a745;
        }
        
        .canvas-container {
            background: white;
            border: 2px solid #ddd;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            overflow: auto;
            position: relative;
        }
        
        #svgCanvas {
            border: 1px solid #ccc;
            background: #fafafa;
            cursor: crosshair;
            display: block;
            margin: 0 auto;
        }
        
        .info-box {
            background: #e7f3ff;
            border-left: 4px solid #2196F3;
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
        }
        
        .output-box {
            background: #f8f9fa;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 15px;
            margin-top: 20px;
        }
        
        .output-box textarea {
            width: 100%;
            min-height: 150px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            resize: vertical;
        }
        
        .status {
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
            font-weight: bold;
        }
        
        .status.info {
            background: #d1ecf1;
            color: #0c5460;
        }
        
        .status.success {
            background: #d4edda;
            color: #155724;
        }
        
        .status.warning {
            background: #fff3cd;
            color: #856404;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸŽ¯ Centerline Generator</h1>
        <p class="subtitle">Create centerline paths by placing points along the SVG path</p>
        
        <div class="controls">
            <div class="control-group">
                <label>SVG Path Input:</label>
                <textarea id="svgPathInput" placeholder="Paste SVG path here (e.g., M 100 100 L 200 200...)"></textarea>
                <button onclick="loadSVG()">Load SVG Path</button>
                <button class="danger" onclick="clearAll()">Clear All</button>
            </div>
            
            <div class="control-group">
                <label>Actions:</label>
                <button onclick="undoLastPoint()">Undo Last Point</button>
                <button class="danger" onclick="clearCenterline()">Clear Centerline</button>
                <button class="success" onclick="exportCenterline()">Export Centerline</button>
            </div>
        </div>
        
        <div class="info-box">
            <strong>Instructions:</strong>
            <ol style="margin-top: 10px; padding-left: 20px;">
                <li>Paste the SVG path from <code>telugu_shape_paths.dart</code></li>
                <li>Click "Load SVG Path" to display the letter</li>
                <li>Click anywhere inside the letter shape to place centerline points</li>
                <li>Points will be placed exactly where you click</li>
                <li>Hover to see a preview of where the point will be placed</li>
                <li>Click "Export Centerline" to get the SVG path string</li>
                <li>Copy the output and paste it into <code>telugu_shape_paths.dart</code></li>
            </ol>
        </div>
        
        <div id="status" class="status info">Ready - Paste SVG path and click 'Load SVG Path' to begin</div>
        
        <div class="canvas-container">
            <svg id="svgCanvas" width="1000" height="1000" viewBox="0 0 1000 1000"></svg>
        </div>
        
        <div class="output-box">
            <label><strong>Generated Centerline Path (SVG):</strong></label>
            <textarea id="outputPath" readonly placeholder="Centerline path will appear here..."></textarea>
            <button onclick="copyToClipboard()">Copy to Clipboard</button>
        </div>
    </div>

    <script>
        let svgElement = null;
        let mainPathElement = null;
        let centerlinePathElement = null;
        let centerlinePoints = [];
        let svgBounds = null;
        let pointCircles = [];
        let previewCircle = null;
        
        function loadSVG() {
            const pathInput = document.getElementById('svgPathInput').value.trim();
            if (!pathInput) {
                alert('Please paste an SVG path');
                return;
            }
            
            svgElement = document.getElementById('svgCanvas');
            svgElement.innerHTML = '';
            centerlinePoints = [];
            pointCircles = [];
            
            // Create main path
            mainPathElement = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            mainPathElement.setAttribute('d', pathInput);
            mainPathElement.setAttribute('fill', '#e3f2fd');
            mainPathElement.setAttribute('stroke', '#1976d2');
            mainPathElement.setAttribute('stroke-width', '2');
            mainPathElement.setAttribute('id', 'mainPath');
            svgElement.appendChild(mainPathElement);
            
            // Get bounds and set viewBox
            setTimeout(() => {
                try {
                    const bbox = mainPathElement.getBBox();
                    svgBounds = bbox;
                    const padding = 50;
                    const viewBox = `${bbox.x - padding} ${bbox.y - padding} ${bbox.width + 2*padding} ${bbox.height + 2*padding}`;
                    svgElement.setAttribute('viewBox', viewBox);
                    svgElement.setAttribute('preserveAspectRatio', 'xMidYMid meet');
                    
                    // Force a reflow to ensure transformations are applied
                    svgElement.getBBox();
                    
                    updateStatus(`SVG loaded. Click anywhere inside the letter to add centerline points.`);
                } catch (e) {
                    console.error('Error getting bounds:', e);
                    updateStatus('Error loading SVG bounds', 'warning');
                }
            }, 100);
            
            // Add click and mouse move handlers
            svgElement.addEventListener('click', handleCanvasClick);
            svgElement.addEventListener('mousemove', handleMouseMove);
        }
        
        function getSVGPoint(event) {
            const rect = svgElement.getBoundingClientRect();
            
            // Get mouse position relative to the SVG element
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            
            // Get viewBox
            const viewBox = svgElement.viewBox.baseVal;
            const svgWidth = rect.width;
            const svgHeight = rect.height;
            
            // Calculate SVG coordinates from viewBox
            const svgX = viewBox.x + (x / svgWidth) * viewBox.width;
            const svgY = viewBox.y + (y / svgHeight) * viewBox.height;
            
            const point = svgElement.createSVGPoint();
            point.x = svgX;
            point.y = svgY;
            
            return point;
        }
        
        function handleMouseMove(event) {
            if (!mainPathElement) return;
            
            const svgPoint = getSVGPoint(event);
            
            // Check if point is inside the SVG shape
            if (mainPathElement.isPointInFill(svgPoint)) {
                // Remove old preview circle
                if (previewCircle && previewCircle.parentNode) {
                    previewCircle.parentNode.removeChild(previewCircle);
                }
                
                // Create preview circle at exact mouse position
                previewCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                previewCircle.setAttribute('cx', svgPoint.x);
                previewCircle.setAttribute('cy', svgPoint.y);
                previewCircle.setAttribute('r', '6');
                previewCircle.setAttribute('fill', 'rgba(255, 87, 34, 0.5)');
                previewCircle.setAttribute('stroke', '#ff5722');
                previewCircle.setAttribute('stroke-width', '2');
                previewCircle.setAttribute('id', 'previewCircle');
                previewCircle.style.pointerEvents = 'none';
                svgElement.appendChild(previewCircle);
            } else {
                // Remove preview if outside the shape
                if (previewCircle && previewCircle.parentNode) {
                    previewCircle.parentNode.removeChild(previewCircle);
                    previewCircle = null;
                }
            }
        }
        
        function handleCanvasClick(event) {
            if (!mainPathElement) return;
            
            // Remove preview circle
            if (previewCircle && previewCircle.parentNode) {
                previewCircle.parentNode.removeChild(previewCircle);
                previewCircle = null;
            }
            
            const svgPoint = getSVGPoint(event);
            
            // Check if point is inside the SVG shape
            if (mainPathElement.isPointInFill(svgPoint)) {
                // Place point exactly where user clicked
                centerlinePoints.push({x: svgPoint.x, y: svgPoint.y});
                updateCenterlinePath();
                updateStatus(`Added point ${centerlinePoints.length} at (${svgPoint.x.toFixed(2)}, ${svgPoint.y.toFixed(2)})`);
            } else {
                updateStatus('Click inside the letter shape to add points', 'warning');
            }
        }
        
        function updateCenterlinePath() {
            if (!svgElement) return;
            
            // Remove existing centerline path
            if (centerlinePathElement) {
                svgElement.removeChild(centerlinePathElement);
            }
            
            // Remove existing point circles
            pointCircles.forEach(circle => {
                if (circle.parentNode) {
                    circle.parentNode.removeChild(circle);
                }
            });
            pointCircles = [];
            
            if (centerlinePoints.length === 0) return;
            
            // Create new centerline path
            centerlinePathElement = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            let pathData = '';
            
            centerlinePoints.forEach((point, index) => {
                if (index === 0) {
                    pathData += `M ${point.x.toFixed(2)} ${point.y.toFixed(2)}`;
                } else {
                    pathData += ` L ${point.x.toFixed(2)} ${point.y.toFixed(2)}`;
                }
            });
            
            centerlinePathElement.setAttribute('d', pathData);
            centerlinePathElement.setAttribute('fill', 'none');
            centerlinePathElement.setAttribute('stroke', '#ff5722');
            centerlinePathElement.setAttribute('stroke-width', '3');
            centerlinePathElement.setAttribute('stroke-dasharray', '5,5');
            svgElement.appendChild(centerlinePathElement);
            
            // Add point markers
            centerlinePoints.forEach((point, index) => {
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', point.x);
                circle.setAttribute('cy', point.y);
                circle.setAttribute('r', '6');
                circle.setAttribute('fill', '#ff5722');
                circle.setAttribute('stroke', 'white');
                circle.setAttribute('stroke-width', '2');
                circle.setAttribute('data-index', index);
                circle.style.cursor = 'pointer';
                
                // Add click handler to remove point
                circle.addEventListener('click', (e) => {
                    e.stopPropagation();
                    removePoint(index);
                });
                
                svgElement.appendChild(circle);
                pointCircles.push(circle);
                
                // Add point number label
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', point.x);
                text.setAttribute('y', point.y - 10);
                text.setAttribute('text-anchor', 'middle');
                text.setAttribute('font-size', '12');
                text.setAttribute('font-weight', 'bold');
                text.setAttribute('fill', '#fff');
                text.setAttribute('stroke', '#ff5722');
                text.setAttribute('stroke-width', '0.5');
                text.textContent = index + 1;
                svgElement.appendChild(text);
            });
            
            // Update output
            document.getElementById('outputPath').value = pathData;
        }
        
        function removePoint(index) {
            if (index >= 0 && index < centerlinePoints.length) {
                centerlinePoints.splice(index, 1);
                updateCenterlinePath();
                updateStatus(`Removed point ${index + 1}. Total points: ${centerlinePoints.length}`);
            }
        }
        
        function undoLastPoint() {
            if (centerlinePoints.length > 0) {
                centerlinePoints.pop();
                updateCenterlinePath();
                updateStatus(`Removed last point. Total points: ${centerlinePoints.length}`);
            } else {
                updateStatus('No points to undo', 'warning');
            }
        }
        
        function clearCenterline() {
            centerlinePoints = [];
            if (centerlinePathElement) {
                svgElement.removeChild(centerlinePathElement);
                centerlinePathElement = null;
            }
            pointCircles.forEach(circle => {
                if (circle.parentNode) {
                    circle.parentNode.removeChild(circle);
                }
            });
            pointCircles = [];
            document.getElementById('outputPath').value = '';
            updateStatus('Centerline cleared');
        }
        
        function clearAll() {
            clearCenterline();
            if (previewCircle && previewCircle.parentNode) {
                previewCircle.parentNode.removeChild(previewCircle);
                previewCircle = null;
            }
            if (mainPathElement) {
                svgElement.removeChild(mainPathElement);
                mainPathElement = null;
            }
            svgBounds = null;
            document.getElementById('svgPathInput').value = '';
            updateStatus('All cleared');
        }
        
        function exportCenterline() {
            if (centerlinePoints.length === 0) {
                alert('No centerline points to export. Please add some points first.');
                return;
            }
            
            let pathData = '';
            centerlinePoints.forEach((point, index) => {
                if (index === 0) {
                    pathData += `M ${point.x.toFixed(2)} ${point.y.toFixed(2)}`;
                } else {
                    pathData += ` L ${point.x.toFixed(2)} ${point.y.toFixed(2)}`;
                }
            });
            
            document.getElementById('outputPath').value = pathData;
            updateStatus(`Exported centerline with ${centerlinePoints.length} points`, 'success');
        }
        
        function copyToClipboard() {
            const output = document.getElementById('outputPath');
            if (!output.value) {
                alert('No centerline path to copy. Please export first.');
                return;
            }
            output.select();
            document.execCommand('copy');
            updateStatus('Copied to clipboard!', 'success');
        }
        
        function updateStatus(message, type = 'info') {
            const statusEl = document.getElementById('status');
            statusEl.textContent = message;
            statusEl.className = `status ${type}`;
        }
    </script>
</body>
</html>

