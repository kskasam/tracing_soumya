<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JSON Stroke Points Generator</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            padding: 30px;
        }
        
        h1 {
            color: #667eea;
            margin-bottom: 10px;
            text-align: center;
        }
        
        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
        }
        
        .controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .control-group {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
        }
        
        .control-group label {
            display: block;
            font-weight: bold;
            margin-bottom: 8px;
            color: #495057;
        }
        
        textarea {
            width: 100%;
            min-height: 100px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
            margin-bottom: 10px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            resize: vertical;
        }
        
        button {
            background: #667eea;
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s;
            margin: 5px 5px 5px 0;
        }
        
        button:hover {
            background: #764ba2;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        
        button.danger {
            background: #dc3545;
        }
        
        button.success {
            background: #28a745;
        }
        
        button.warning {
            background: #ffc107;
            color: #000;
        }
        
        .canvas-container {
            background: white;
            border: 2px solid #ddd;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            overflow: auto;
            position: relative;
        }
        
        #svgCanvas {
            border: 1px solid #ccc;
            background: #fafafa;
            cursor: crosshair;
            display: block;
            margin: 0 auto;
        }
        
        .info-box {
            background: #e7f3ff;
            border-left: 4px solid #2196F3;
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
        }
        
        .output-box {
            background: #f8f9fa;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 15px;
            margin-top: 20px;
        }
        
        .output-box textarea {
            width: 100%;
            min-height: 200px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            resize: vertical;
        }
        
        .status {
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
            font-weight: bold;
        }
        
        .status.info {
            background: #d1ecf1;
            color: #0c5460;
        }
        
        .status.success {
            background: #d4edda;
            color: #155724;
        }
        
        .status.warning {
            background: #fff3cd;
            color: #856404;
        }
        
        .strokes-panel {
            background: #fff;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 15px;
            margin-top: 15px;
            max-height: 300px;
            overflow-y: auto;
        }
        
        .stroke-item {
            padding: 10px;
            margin: 5px 0;
            border: 1px solid #ddd;
            border-radius: 5px;
            background: #f8f9fa;
        }
        
        .stroke-item.active {
            border-color: #667eea;
            background: #e7f3ff;
        }
        
        .stroke-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
        }
        
        .stroke-info {
            font-size: 12px;
            color: #666;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üìù JSON Stroke Points Generator</h1>
        <p class="subtitle">Create stroke point JSON files for tracing paths</p>
        
        <div class="controls">
            <div class="control-group">
                <label>SVG Path Input:</label>
                <textarea id="svgPathInput" placeholder="Paste SVG path here (e.g., M 100 100 L 200 200...)"></textarea>
                <button onclick="loadSVG()">Load SVG Path</button>
                <button class="danger" onclick="clearAll()">Clear All</button>
            </div>
            
            <div class="control-group">
                <label>Stroke Controls:</label>
                <button onclick="startNewStroke()">Start New Stroke</button>
                <button class="warning" onclick="undoLastPoint()">Undo Last Point</button>
                <button class="danger" onclick="clearCurrentStroke()">Clear Current Stroke</button>
                <button class="success" onclick="exportJSON()">Export JSON</button>
            </div>
        </div>
        
        <div class="info-box">
            <strong>Instructions:</strong>
            <ol style="margin-top: 10px; padding-left: 20px;">
                <li>Paste the SVG path from your shape file</li>
                <li>Click "Load SVG Path" to display the shape</li>
                <li>Click "Start New Stroke" to begin the first stroke</li>
                <li>Click anywhere inside the shape to add points to the current stroke</li>
                <li>Click "Start New Stroke" again to begin a new stroke</li>
                <li>Click "Export JSON" to generate the JSON file</li>
                <li>Copy the output and save it as a JSON file</li>
            </ol>
        </div>
        
        <div id="status" class="status info">Ready - Paste SVG path and click 'Load SVG Path' to begin</div>
        
        <div class="canvas-container">
            <svg id="svgCanvas" width="1000" height="1000" viewBox="0 0 1000 1000"></svg>
        </div>
        
        <div class="strokes-panel" id="strokesPanel" style="display: none;">
            <strong>Strokes:</strong>
            <div id="strokesList"></div>
        </div>
        
        <div class="output-box">
            <label><strong>Generated JSON:</strong></label>
            <textarea id="outputJSON" readonly placeholder="JSON will appear here..."></textarea>
            <button onclick="copyToClipboard()">Copy to Clipboard</button>
        </div>
    </div>

    <script>
        let svgElement = null;
        let mainPathElement = null;
        let svgBounds = null;
        let strokes = []; // Array of strokes, each stroke is an array of points
        let currentStrokeIndex = -1; // -1 means no active stroke
        let previewCircle = null;
        let strokeColors = [
            '#ff5722', '#4caf50', '#2196f3', '#ff9800', '#9c27b0',
            '#f44336', '#00bcd4', '#8bc34a', '#ffc107', '#e91e63'
        ];
        
        function loadSVG() {
            const pathInput = document.getElementById('svgPathInput').value.trim();
            if (!pathInput) {
                alert('Please paste an SVG path');
                return;
            }
            
            svgElement = document.getElementById('svgCanvas');
            svgElement.innerHTML = '';
            strokes = [];
            currentStrokeIndex = -1;
            
            // Create main path
            mainPathElement = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            mainPathElement.setAttribute('d', pathInput);
            mainPathElement.setAttribute('fill', '#e3f2fd');
            mainPathElement.setAttribute('stroke', '#1976d2');
            mainPathElement.setAttribute('stroke-width', '2');
            mainPathElement.setAttribute('id', 'mainPath');
            svgElement.appendChild(mainPathElement);
            
            // Get bounds and set viewBox
            setTimeout(() => {
                try {
                    const bbox = mainPathElement.getBBox();
                    svgBounds = bbox;
                    const padding = 50;
                    const viewBox = `${bbox.x - padding} ${bbox.y - padding} ${bbox.width + 2*padding} ${bbox.height + 2*padding}`;
                    svgElement.setAttribute('viewBox', viewBox);
                    svgElement.setAttribute('preserveAspectRatio', 'xMidYMid meet');
                    
                    updateStatus(`SVG loaded. Click 'Start New Stroke' to begin adding points.`);
                    updateStrokesPanel();
                } catch (e) {
                    console.error('Error getting bounds:', e);
                    updateStatus('Error loading SVG bounds', 'warning');
                }
            }, 100);
            
            // Add click and mouse move handlers
            svgElement.addEventListener('click', handleCanvasClick);
            svgElement.addEventListener('mousemove', handleMouseMove);
        }
        
        function getSVGPoint(event) {
            const rect = svgElement.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            
            const viewBox = svgElement.viewBox.baseVal;
            const svgWidth = rect.width;
            const svgHeight = rect.height;
            
            const svgX = viewBox.x + (x / svgWidth) * viewBox.width;
            const svgY = viewBox.y + (y / svgHeight) * viewBox.height;
            
            const point = svgElement.createSVGPoint();
            point.x = svgX;
            point.y = svgY;
            
            return point;
        }
        
        function handleMouseMove(event) {
            if (!mainPathElement || currentStrokeIndex === -1) return;
            
            const svgPoint = getSVGPoint(event);
            
            if (mainPathElement.isPointInFill(svgPoint)) {
                if (previewCircle && previewCircle.parentNode) {
                    previewCircle.parentNode.removeChild(previewCircle);
                }
                
                previewCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                previewCircle.setAttribute('cx', svgPoint.x);
                previewCircle.setAttribute('cy', svgPoint.y);
                previewCircle.setAttribute('r', '6');
                previewCircle.setAttribute('fill', 'rgba(255, 87, 34, 0.5)');
                previewCircle.setAttribute('stroke', '#ff5722');
                previewCircle.setAttribute('stroke-width', '2');
                previewCircle.setAttribute('id', 'previewCircle');
                previewCircle.style.pointerEvents = 'none';
                svgElement.appendChild(previewCircle);
            } else {
                if (previewCircle && previewCircle.parentNode) {
                    previewCircle.parentNode.removeChild(previewCircle);
                    previewCircle = null;
                }
            }
        }
        
        function handleCanvasClick(event) {
            if (!mainPathElement) return;
            
            if (currentStrokeIndex === -1) {
                updateStatus('Please start a new stroke first', 'warning');
                return;
            }
            
            if (previewCircle && previewCircle.parentNode) {
                previewCircle.parentNode.removeChild(previewCircle);
                previewCircle = null;
            }
            
            const svgPoint = getSVGPoint(event);
            
            if (mainPathElement.isPointInFill(svgPoint)) {
                // Add point to current stroke
                strokes[currentStrokeIndex].push({x: svgPoint.x, y: svgPoint.y});
                updateStrokeVisualization();
                updateStrokesPanel();
                updateStatus(`Stroke ${currentStrokeIndex + 1}: Added point ${strokes[currentStrokeIndex].length} at (${svgPoint.x.toFixed(2)}, ${svgPoint.y.toFixed(2)})`);
            } else {
                updateStatus('Click inside the shape to add points', 'warning');
            }
        }
        
        function startNewStroke() {
            if (!mainPathElement) {
                updateStatus('Please load SVG first', 'warning');
                return;
            }
            
            currentStrokeIndex = strokes.length;
            strokes.push([]);
            updateStatus(`Started stroke ${currentStrokeIndex + 1}. Click inside the shape to add points.`);
            updateStrokesPanel();
        }
        
        function undoLastPoint() {
            if (currentStrokeIndex === -1 || strokes[currentStrokeIndex].length === 0) {
                updateStatus('No points to undo', 'warning');
                return;
            }
            
            strokes[currentStrokeIndex].pop();
            updateStrokeVisualization();
            updateStrokesPanel();
            updateStatus(`Removed last point. Stroke ${currentStrokeIndex + 1} now has ${strokes[currentStrokeIndex].length} points.`);
        }
        
        function clearCurrentStroke() {
            if (currentStrokeIndex === -1) {
                updateStatus('No active stroke to clear', 'warning');
                return;
            }
            
            strokes[currentStrokeIndex] = [];
            updateStrokeVisualization();
            updateStrokesPanel();
            updateStatus(`Cleared stroke ${currentStrokeIndex + 1}`);
        }
        
        function clearAll() {
            strokes = [];
            currentStrokeIndex = -1;
            if (previewCircle && previewCircle.parentNode) {
                previewCircle.parentNode.removeChild(previewCircle);
                previewCircle = null;
            }
            if (mainPathElement) {
                // Remove all stroke visualizations but keep the main path
                const paths = svgElement.querySelectorAll('.stroke-path, .stroke-point');
                paths.forEach(p => p.parentNode.removeChild(p));
            }
            svgBounds = null;
            document.getElementById('svgPathInput').value = '';
            document.getElementById('outputJSON').value = '';
            updateStrokesPanel();
            updateStatus('All cleared');
        }
        
        function updateStrokeVisualization() {
            // Remove existing stroke visualizations
            const existingPaths = svgElement.querySelectorAll('.stroke-path');
            const existingPoints = svgElement.querySelectorAll('.stroke-point');
            existingPaths.forEach(p => p.parentNode.removeChild(p));
            existingPoints.forEach(p => p.parentNode.removeChild(p));
            
            // Draw all strokes
            strokes.forEach((stroke, strokeIdx) => {
                if (stroke.length === 0) return;
                
                const color = strokeColors[strokeIdx % strokeColors.length];
                
                // Draw stroke path
                const pathElement = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                let pathData = '';
                stroke.forEach((point, idx) => {
                    if (idx === 0) {
                        pathData += `M ${point.x.toFixed(2)} ${point.y.toFixed(2)}`;
                    } else {
                        pathData += ` L ${point.x.toFixed(2)} ${point.y.toFixed(2)}`;
                    }
                });
                
                pathElement.setAttribute('d', pathData);
                pathElement.setAttribute('fill', 'none');
                pathElement.setAttribute('stroke', color);
                pathElement.setAttribute('stroke-width', '3');
                pathElement.setAttribute('stroke-dasharray', '5,3');
                pathElement.setAttribute('class', 'stroke-path');
                svgElement.appendChild(pathElement);
                
                // Draw points
                stroke.forEach((point, pointIdx) => {
                    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    circle.setAttribute('cx', point.x);
                    circle.setAttribute('cy', point.y);
                    circle.setAttribute('r', '5');
                    circle.setAttribute('fill', color);
                    circle.setAttribute('stroke', 'white');
                    circle.setAttribute('stroke-width', '2');
                    circle.setAttribute('class', 'stroke-point');
                    svgElement.appendChild(circle);
                    
                    // Add point number
                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    text.setAttribute('x', point.x);
                    text.setAttribute('y', point.y - 8);
                    text.setAttribute('text-anchor', 'middle');
                    text.setAttribute('font-size', '10');
                    text.setAttribute('font-weight', 'bold');
                    text.setAttribute('fill', '#fff');
                    text.setAttribute('stroke', color);
                    text.setAttribute('stroke-width', '0.5');
                    text.textContent = pointIdx + 1;
                    text.setAttribute('class', 'stroke-point');
                    svgElement.appendChild(text);
                });
            });
        }
        
        function updateStrokesPanel() {
            const panel = document.getElementById('strokesPanel');
            const list = document.getElementById('strokesList');
            
            if (strokes.length === 0) {
                panel.style.display = 'none';
                return;
            }
            
            panel.style.display = 'block';
            list.innerHTML = '';
            
            strokes.forEach((stroke, idx) => {
                const item = document.createElement('div');
                item.className = 'stroke-item' + (idx === currentStrokeIndex ? ' active' : '');
                item.innerHTML = `
                    <div class="stroke-header">
                        <strong>Stroke ${idx + 1}</strong>
                        <span class="stroke-info">${stroke.length} points</span>
                    </div>
                `;
                list.appendChild(item);
            });
        }
        
        function normalizePoint(point) {
            // Normalize point to 0.0-1.0 range based on SVG bounds
            if (!svgBounds) return {x: 0, y: 0};
            
            const normX = (point.x - svgBounds.x) / svgBounds.width;
            const normY = (point.y - svgBounds.y) / svgBounds.height;
            
            return {
                x: Math.max(0, Math.min(1, normX)),
                y: Math.max(0, Math.min(1, normY))
            };
        }
        
        function exportJSON() {
            if (strokes.length === 0 || strokes.every(s => s.length === 0)) {
                alert('No strokes to export. Please add at least one stroke with points.');
                return;
            }
            
            // Filter out empty strokes
            const validStrokes = strokes.filter(s => s.length > 0);
            
            const jsonData = {
                strokes: validStrokes.map(stroke => ({
                    points: stroke.map(point => {
                        const norm = normalizePoint(point);
                        return `${norm.x.toFixed(4)},${norm.y.toFixed(4)}`;
                    })
                }))
            };
            
            const jsonString = JSON.stringify(jsonData, null, 2);
            document.getElementById('outputJSON').value = jsonString;
            updateStatus(`Exported ${validStrokes.length} stroke(s) with ${validStrokes.reduce((sum, s) => sum + s.length, 0)} total points`, 'success');
        }
        
        function copyToClipboard() {
            const output = document.getElementById('outputJSON');
            if (!output.value) {
                alert('No JSON to copy. Please export first.');
                return;
            }
            output.select();
            document.execCommand('copy');
            updateStatus('Copied to clipboard!', 'success');
        }
        
        function updateStatus(message, type = 'info') {
            const statusEl = document.getElementById('status');
            statusEl.textContent = message;
            statusEl.className = `status ${type}`;
        }
    </script>
</body>
</html>

